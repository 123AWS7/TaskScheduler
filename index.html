<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>TaskScheduler by Naios</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">TaskScheduler</h1>
      <h2 class="project-tagline">Use functors, lambdas and std::chrono to schedule tasks in the near future</h2>
      <a href="https://github.com/Naios/TaskScheduler" class="btn">View on GitHub</a>
      <a href="https://github.com/Naios/TaskScheduler/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Naios/TaskScheduler/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="c11-task-scheduler" class="anchor" href="#c11-task-scheduler" aria-hidden="true"><span class="octicon octicon-link"></span></a>C++11 Task Scheduler</h1>

<p><a href="https://travis-ci.org/Naios/TaskScheduler"><img src="https://travis-ci.org/Naios/TaskScheduler.svg?branch=master" alt="Build Status"></a> <a href="https://scan.coverity.com/projects/5998"><img src="https://scan.coverity.com/projects/5998/badge.svg" alt="Coverity Scan Build Status"></a></p>

<p><a href="https://github.com/Naios/TaskScheduler/blob/master/doc/examples/preview.cpp"><img src="https://raw.githubusercontent.com/Naios/TaskScheduler/master/doc/preview/Preview.gif" alt="Preview"></a></p>

<blockquote>
<p>Use <strong>std::chrono::duration</strong> to schedule functional types (<strong>std::function</strong>, std::bind, lambdas and functors) in the near future. Easy and safe to use and <strong>dependency free</strong>. Offers the possibility to reschedule, <strong>repeat</strong>, manipulate and <strong>cancel tasks</strong>.</p>
</blockquote>

<hr>

<h2>
<a id="table-of-contents" class="anchor" href="#table-of-contents" aria-hidden="true"><span class="octicon octicon-link"></span></a>Table of Contents</h2>

<ul>
<li>
<strong><a href="#usage-instructions">Usage Instructions</a></strong>

<ul>
<li><strong><a href="#scheduling-tasks">Scheduling Tasks</a></strong></li>
<li><strong><a href="#duration-literals-and-typedefs">Duration literals and typedefs</a></strong></li>
<li><strong><a href="#updating-the-scheduler">Updating the Scheduler</a></strong></li>
<li><strong><a href="#groups">Groups</a></strong></li>
<li><strong><a href="#contexts">Contexts</a></strong></li>
</ul>
</li>
<li><strong><a href="#coverage">Coverage</a></strong></li>
<li><strong><a href="#requirements">Requirements</a></strong></li>
<li><strong><a href="#licence">License</a></strong></li>
</ul>

<h2>
<a id="usage-instructions" class="anchor" href="#usage-instructions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage Instructions</h2>

<h3>
<a id="schedulig-tasks" class="anchor" href="#schedulig-tasks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Schedulig tasks</h3>

<p>Scheduling a task is very easy, just declare a <code>TaskScheduler</code> and use <code>TaskScheduler::Schedule</code>.</p>

<div class="highlight highlight-c++"><pre>#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>iostream<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">&lt;</span>chrono<span class="pl-pds">&gt;</span></span>
#<span class="pl-k">include</span> <span class="pl-s"><span class="pl-pds">"</span>TaskScheduler.hpp<span class="pl-pds">"</span></span>

<span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">tsc</span><span class="pl-k">;</span>

TaskScheduler scheduler;

scheduler.Schedule(std::chrono::seconds(<span class="pl-c1">10</span>), [](TaskContext context)
{
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>This is executed once.<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
});</pre></div>

<h3>
<a id="duration-literals-and-typedefs" class="anchor" href="#duration-literals-and-typedefs" aria-hidden="true"><span class="octicon octicon-link"></span></a>Duration literals and typedefs</h3>

<p>If your compiler and projects supports C++14 use <strong><a href="http://en.cppreference.com/w/cpp/chrono/operator%22%22ms">std::duration_literals</a></strong> for better readability like:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">using</span> <span class="pl-k">namespace</span> <span class="pl-en">std</span>::literals<span class="pl-k">;</span>

scheduler.Schedule(10s, ...);</pre></div>

<p>Using C++11 you can also define <code>std::chrono::duration</code> shorthand typedefs for easier usage:</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">typedef</span> std::chrono::milliseconds Milliseconds;
<span class="pl-k">typedef</span> std::chrono::seconds Seconds;
<span class="pl-k">typedef</span> std::chrono::minutes Minutes;
<span class="pl-k">typedef</span> std::chrono::hours Hours;

scheduler.Schedule(Seconds(<span class="pl-c1">10</span>), ...);</pre></div>

<h3>
<a id="updating-the-scheduler" class="anchor" href="#updating-the-scheduler" aria-hidden="true"><span class="octicon octicon-link"></span></a>Updating the Scheduler</h3>

<p>In most cases you will use an application-/ gameloop which is called in a constant interval, otherwise you need to create a thread to do so:</p>

<div class="highlight highlight-c++"><pre><span class="pl-c">// An update loop where diff is in milliseconds</span>
<span class="pl-k">void</span> <span class="pl-en">Update</span>(<span class="pl-k">unsigned</span> <span class="pl-k">int</span> diff)
{
    scheduler.<span class="pl-c1">Update</span>(<span class="pl-c1">std::chrono::milliseconds</span>(diff));
}

<span class="pl-c">// An update loop where diff is in seconds</span>
<span class="pl-k">void</span> <span class="pl-en">Update</span>(std::chrono::seconds&amp; diff)
{
    scheduler.<span class="pl-c1">Update</span>(diff);
}

<span class="pl-c">// An update loop where no diff time is given</span>
<span class="pl-k">void</span> <span class="pl-en">Update</span>()
{
    scheduler.<span class="pl-c1">Update</span>();
}
</pre></div>

<h3>
<a id="reapeat-tasks" class="anchor" href="#reapeat-tasks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reapeat Tasks</h3>

<div class="highlight highlight-c++"><pre><span class="pl-c">// Schedule a simple function that is executed every 10s</span>
scheduler
    .Schedule(std::chrono::seconds(<span class="pl-c1">10</span>), [](TaskContext context)
    {
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>This is executed once.<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
    })
    <span class="pl-c">// Lazy overloading, just concat everything together...</span>
    .Schedule(std::chrono::seconds(<span class="pl-c1">10</span>), [](TaskContext context)
    {
        std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>This is executed every 10s...<span class="pl-pds">"</span></span> &lt;&lt; std::endl;

        <span class="pl-c">// Repeat this event.</span>
        context.<span class="pl-c1">Repeat</span>();
    });

<span class="pl-c">// Update the scheduler to now</span>
scheduler.Update();

<span class="pl-c">// ...or add a difftime, useful if you are using a global update tick.</span>
scheduler.Update(std::chrono::milliseconds(<span class="pl-c1">200</span>));</pre></div>

<h3>
<a id="groups" class="anchor" href="#groups" aria-hidden="true"><span class="octicon octicon-link"></span></a>Groups</h3>

<p>Since you can't compare std::functions to each other  you can organize scheduled functions in groups to manage it.</p>

<div class="highlight highlight-c++"><pre><span class="pl-k">enum</span> ScheduledGroups
{
    GROUP_FIRST, <span class="pl-c">// Group 0 is also a group ,-)</span>
    GROUP_SECOND,
};

scheduler.Schedule(std::chrono::seconds(<span class="pl-c1">5</span>), GROUP_FIRST, [](TaskContext context)
{
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>You won't see me...<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
});

<span class="pl-c">// Cancel the group GROUP_FIRST</span>
scheduler.CancelGroup(GROUP_FIRST);

<span class="pl-c">// ... or cancel all goups.</span>
scheduler.CancelAll();</pre></div>

<h3>
<a id="contexts" class="anchor" href="#contexts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contexts</h3>

<p>To access the TaskScheduler safely from within a scheduled function there is a TaskContext provided. <strong>It's important that you never pass the TaskScheduler as lambda capture! Use the TaskContext instead.</strong> The task context provides the ability to reschedule the executed function, cancel groups or schedule new tasks.</p>

<p>If you schedule new tasks from within a context the time is calculated from the context, it's possible that the function gets executed at the same update tick!</p>

<div class="highlight highlight-c++"><pre>scheduler.Schedule(std::chrono::milliseconds(<span class="pl-c1">1500</span>), [](TaskContext context)
{
    std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Message (1/3)<span class="pl-pds">"</span></span> &lt;&lt; std::endl;

    context
        .<span class="pl-c1">Schedule</span>(<span class="pl-c1">std::chrono::milliseconds</span>(<span class="pl-c1">800</span>), [](TaskContext context)
        {
            std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Message (2/3)<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
        })
        .<span class="pl-c1">Schedule</span>(<span class="pl-c1">std::chrono::milliseconds</span>(<span class="pl-c1">900</span>), [](TaskContext context)
        {
            std::cout &lt;&lt; <span class="pl-s"><span class="pl-pds">"</span>Message (3/3)<span class="pl-pds">"</span></span> &lt;&lt; std::endl;
            context-&gt;<span class="pl-c1">CancelAll</span>();
        });
});

<span class="pl-c">// Only 1 update is called and all 3 functions are executed.</span>
scheduler.Update(std::chrono::seconds(<span class="pl-c1">60</span>));</pre></div>

<h2>
<a id="coverage" class="anchor" href="#coverage" aria-hidden="true"><span class="octicon octicon-link"></span></a>Coverage</h2>

<p>Automatic unit tests are automatically executed through Travis CI to check the code integrity.
See the <a href="https://github.com/Naios/TaskScheduler/blob/master/Test.cpp">tests for details</a>.</p>

<h2>
<a id="requirements" class="anchor" href="#requirements" aria-hidden="true"><span class="octicon octicon-link"></span></a>Requirements</h2>

<p>The TaskScheduler is <strong>dependency free</strong> and was tested with following <strong>c++11 capable</strong> compiler and confirmed to work:</p>

<ul>
<li>Visual Studio 2013 Update 4</li>
<li>Visual Studio 2015</li>
<li>GNU GCC 4.8+</li>
<li>Clang 3.4+</li>
</ul>

<h2>
<a id="license" class="anchor" href="#license" aria-hidden="true"><span class="octicon octicon-link"></span></a>License</h2>

<p>The TaskScheduler is licensed under the <a href="https://raw.githubusercontent.com/Naios/TaskScheduler/master/LICENSE">Apache 2 License</a>.</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Naios/TaskScheduler">TaskScheduler</a> is maintained by <a href="https://github.com/Naios">Naios</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
