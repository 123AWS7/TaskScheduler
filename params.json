{"name":"Taskscheduler","tagline":"C++11 Task Scheduler: Use std::function, lambdas and std::chrono to schedule tasks in the near future","body":"# C++11 Task Scheduler\r\n[![Build Status](https://travis-ci.org/Naios/TaskScheduler.svg?branch=master)](https://travis-ci.org/Naios/TaskScheduler) [![Coverity Scan Build Status](https://scan.coverity.com/projects/5998/badge.svg)](https://scan.coverity.com/projects/5998)\r\n\r\n[![Preview](https://raw.githubusercontent.com/Naios/TaskScheduler/master/doc/preview/Preview.gif)](https://github.com/Naios/TaskScheduler/blob/master/doc/examples/preview.cpp)\r\n\r\n> Use **std::chrono::duration** to schedule functional types (**std::function**, std::bind, lambdas and functors) in the near future. Easy and safe to use and **dependency free**. Offers the possibility to reschedule, **repeat**, manipulate and **cancel tasks**.\r\n\r\n***\r\n\r\n## Table of Contents\r\n\r\n* **[Usage Instructions](#usage-instructions)**\r\n  * **[Scheduling Tasks](#scheduling-tasks)**\r\n  * **[Duration literals and typedefs](#duration-literals-and-typedefs)**\r\n  * **[Updating the Scheduler](#updating-the-scheduler)**\r\n  * **[Groups](#groups)**\r\n  * **[Contexts](#contexts)**\r\n* **[Coverage](#coverage)**\r\n* **[Requirements](#requirements)**\r\n* **[License](#licence)**\r\n\r\n## Usage Instructions\r\n### Schedulig tasks\r\n\r\nScheduling a task is very easy, just declare a `TaskScheduler` and use `TaskScheduler::Schedule`.\r\n\r\n```c++\r\n#include <iostream>\r\n#include <chrono>\r\n#include \"TaskScheduler.hpp\"\r\n\r\nusing namespace tsc;\r\n\r\nTaskScheduler scheduler;\r\n\r\nscheduler.Schedule(std::chrono::seconds(10), [](TaskContext context)\r\n{\r\n    std::cout << \"This is executed once.\" << std::endl;\r\n});\r\n```\r\n\r\n### Duration literals and typedefs\r\n\r\nIf your compiler and projects supports C++14 use **[std::duration_literals](http://en.cppreference.com/w/cpp/chrono/operator%22%22ms)** for better readability like:\r\n\r\n```c++\r\nusing namespace std::literals;\r\n\r\nscheduler.Schedule(10s, ...);\r\n```\r\n\r\nUsing C++11 you can also define `std::chrono::duration` shorthand typedefs for easier usage:\r\n\r\n```c++\r\ntypedef std::chrono::milliseconds Milliseconds;\r\ntypedef std::chrono::seconds Seconds;\r\ntypedef std::chrono::minutes Minutes;\r\ntypedef std::chrono::hours Hours;\r\n\r\nscheduler.Schedule(Seconds(10), ...);\r\n```\r\n\r\n### Updating the Scheduler\r\n\r\nIn most cases you will use an application-/ gameloop which is called in a constant interval, otherwise you need to create a thread to do so:\r\n\r\n```c++\r\n// An update loop where diff is in milliseconds\r\nvoid Update(unsigned int diff)\r\n{\r\n    scheduler.Update(std::chrono::milliseconds(diff));\r\n}\r\n\r\n// An update loop where diff is in seconds\r\nvoid Update(std::chrono::seconds& diff)\r\n{\r\n    scheduler.Update(diff);\r\n}\r\n\r\n// An update loop where no diff time is given\r\nvoid Update()\r\n{\r\n    scheduler.Update();\r\n}\r\n\r\n```\r\n\r\n### Reapeat Tasks\r\n\r\n```c++\r\n// Schedule a simple function that is executed every 10s\r\nscheduler\r\n\t.Schedule(std::chrono::seconds(10), [](TaskContext context)\r\n\t{\r\n\t    std::cout << \"This is executed once.\" << std::endl;\r\n\t})\r\n\t// Lazy overloading, just concat everything together...\r\n\t.Schedule(std::chrono::seconds(10), [](TaskContext context)\r\n\t{\r\n\t    std::cout << \"This is executed every 10s...\" << std::endl;\r\n\r\n\t    // Repeat this event.\r\n\t    context.Repeat();\r\n\t});\r\n\r\n// Update the scheduler to now\r\nscheduler.Update();\r\n\r\n// ...or add a difftime, useful if you are using a global update tick.\r\nscheduler.Update(std::chrono::milliseconds(200));\r\n```\r\n\r\n### Groups\r\nSince you can't compare std::functions to each other  you can organize scheduled functions in groups to manage it.\r\n```c++\r\nenum ScheduledGroups\r\n{\r\n    GROUP_FIRST, // Group 0 is also a group ,-)\r\n    GROUP_SECOND,\r\n};\r\n\r\nscheduler.Schedule(std::chrono::seconds(5), GROUP_FIRST, [](TaskContext context)\r\n{\r\n    std::cout << \"You won't see me...\" << std::endl;\r\n});\r\n\r\n// Cancel the group GROUP_FIRST\r\nscheduler.CancelGroup(GROUP_FIRST);\r\n\r\n// ... or cancel all goups.\r\nscheduler.CancelAll();\r\n```\r\n\r\n### Contexts\r\nTo access the TaskScheduler safely from within a scheduled function there is a TaskContext provided. **It's important that you never pass the TaskScheduler as lambda capture! Use the TaskContext instead.** The task context provides the ability to reschedule the executed function, cancel groups or schedule new tasks.\r\n\r\nIf you schedule new tasks from within a context the time is calculated from the context, it's possible that the function gets executed at the same update tick!\r\n\r\n```c++\r\nscheduler.Schedule(std::chrono::milliseconds(1500), [](TaskContext context)\r\n{\r\n    std::cout << \"Message (1/3)\" << std::endl;\r\n\r\n    context\r\n        .Schedule(std::chrono::milliseconds(800), [](TaskContext context)\r\n        {\r\n            std::cout << \"Message (2/3)\" << std::endl;\r\n        })\r\n        .Schedule(std::chrono::milliseconds(900), [](TaskContext context)\r\n        {\r\n            std::cout << \"Message (3/3)\" << std::endl;\r\n            context->CancelAll();\r\n        });\r\n});\r\n\r\n// Only 1 update is called and all 3 functions are executed.\r\nscheduler.Update(std::chrono::seconds(60));\r\n```\r\n\r\n## Coverage\r\nAutomatic unit tests are automatically executed through Travis CI to check the code integrity.\r\nSee the [tests for details](https://github.com/Naios/TaskScheduler/blob/master/Test.cpp).\r\n\r\n## Requirements\r\nThe TaskScheduler is **dependency free** and was tested with following **c++11 capable** compiler and confirmed to work:\r\n\r\n* Visual Studio 2013 Update 4\r\n* Visual Studio 2015\r\n* GNU GCC 4.8+\r\n* Clang 3.4+\r\n\r\n## License\r\nThe TaskScheduler is licensed under the [Apache 2 License](https://raw.githubusercontent.com/Naios/TaskScheduler/master/LICENSE).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}